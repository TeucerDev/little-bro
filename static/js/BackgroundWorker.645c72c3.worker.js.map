{"version":3,"file":"static/js/BackgroundWorker.645c72c3.worker.js","mappings":"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ejD,IAAI8C,GAAS5C,IAAI0C,EAAc1P,GACvC4L,EAASpB,KAAI,SAAA4C,GAAC,OAAI4C,EAAK5C,EAAGpN,MAG5B,IC9ZHqR,EACAC,EACAC,EACAC,EACA9D,ECJS+D,EAAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAEnC,CAAI,YAAJ,OADJ,CAAC,QAAS,MAAO,UAAW,QAAS,OAAQ,SAsP9C,UAvJQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,mBACA,cACA,iBACA,iBACA,WACA,aACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAImC,CACnC,mBACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,eACA,gBC7LF,SAASC,EAASC,EAAkBC,GAAmG,IAA5EC,EAA2E,wDAC9HC,EAAc,IAAI9F,IAAgB+F,EAAiB,IAAI/F,IAE7D,SAASgG,EAAMC,EAAeC,GACxBA,EAAUJ,EAAYzF,IAAI4F,GACzBA,EAAK/G,SAAS7I,SAAQ,SAAA8P,GACzB,IAAMvB,EAAKuB,EACXL,EAAY1F,IAAIwE,IAAOmB,EA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","sources":["../node_modules/@babel/runtime/regenerator/index.js","../node_modules/regenerator-runtime/runtime.js","../webpack/bootstrap","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/background.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts"],"sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\r\nexport function getRandomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\nexport function getRandomIntInclusive(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\r\n}\r\nexport function getRandomArbitrary(min, max) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Assumes that the object entries are all primitives + objects\r\n * shallow copy the object,\r\n * deep copy the\r\n * @param obj\r\n * @returns\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (!obj) return obj\r\n  if (!Object.keys(obj).length) return {} as T\r\n  const ret = { ...obj }\r\n  Object.entries(obj).forEach(([k, v]: any) => {\r\n    if (typeof v !== \"object\") return\r\n    ret[k] = JSON.parse(JSON.stringify(v))\r\n  })\r\n  return ret\r\n}\r\n\r\nexport const clamp = (val, low, high) => {\r\n  if (val < low) return low;\r\n  if (val > high) return high;\r\n  return val\r\n}\r\nexport const getArrLastElement = (arr) =>\r\n  arr.length ? arr[arr.length - 1] : null\r\n\r\nexport const clamp01 = (val) => clamp(val, 0, 1)\r\nexport const clampPercent = (val) => clamp(val, 0, 100)\r\n\r\n//use to pretty print timestamps, or anything really.\r\nexport function strPadLeft(string, pad, length) {\r\n  return (new Array(length + 1).join(pad) + string).slice(-length);\r\n}\r\n\r\n//fuzzy compare strings. longer the distance, the higher the mismatch.\r\nexport function hammingDistance(str1, str2) {\r\n  var dist = 0;\r\n  str1 = str1.toLowerCase();\r\n  str2 = str2.toLowerCase();\r\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\r\n    let match = true\r\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\r\n      match = false\r\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\r\n      match = true\r\n    if (!match) dist++\r\n  }\r\n  return dist;\r\n}\r\n\r\n//multiplies every numerical value in the obj by a multiplier.\r\nexport function objMultiplication(obj, multi) {\r\n  if (multi === 1) return obj\r\n  Object.keys(obj).forEach((prop: any) => {\r\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\r\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\r\n  })\r\n  return obj\r\n}\r\n\r\n//assign obj.[keys...] = value\r\nexport function layeredAssignment(obj, keys: readonly string[], value) {\r\n  keys.reduce((accu, key, i, arr) => {\r\n    if (i === arr.length - 1) return (accu[key] = value)\r\n    if (!accu[key]) accu[key] = {}\r\n    return accu[key]\r\n  }, obj)\r\n  return obj\r\n}\r\n//get the value in a nested object, giving array of path\r\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\r\n  if (!obj || !keys) return undefined;\r\n  !Array.isArray(keys) && console.error(keys)\r\n  return keys.reduce((a, k) => a?.[k], obj)\r\n}\r\n//delete the value denoted by the path. Will also delete empty objects as well.\r\nexport function deletePropPath(obj, path) {\r\n  const tempPath = [...path]\r\n  const lastKey = tempPath.pop()\r\n  const objPathed = objPathValue(obj, tempPath)\r\n  delete objPathed?.[lastKey];\r\n}\r\n\r\nexport function objClearEmpties(o) {\r\n  for (const k in o) {\r\n    if (typeof o[k] !== \"object\") continue\r\n    objClearEmpties(o[k])\r\n    if (!Object.keys(o[k]).length) delete o[k];\r\n  }\r\n}\r\nexport function crawlObject(obj, keys, validate, cb) {\r\n  if (validate(obj)) cb(obj, keys)\r\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\r\n}\r\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\r\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\r\n\r\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\r\n  return typeof value === \"function\" ? (value as any)(arg) : value\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(items.map(t => map(t))) as any\r\n}\r\n\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\r\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\r\n  return Object.fromEntries(Object.entries(obj).map(\r\n    ([k, v], i) => [k, fn(v, k, i)]\r\n  )) as any\r\n}\r\n\r\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\r\n  for (let i = from; i <= to; i++) yield i;\r\n};\r\n\r\nexport function range(from: number, to: number): number[] {\r\n  return [...rangeGen(from, to)]\r\n}\r\n\r\nexport function assertUnreachable(value: never): never {\r\n  throw new Error(`Should not reach this with value ${value}`)\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\r\n\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype Any = Num | Str\r\n\r\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\r\nexport const unit = percent(1), naught = percent(0)\r\n\r\nexport function constant(value: number, info?: Info): NumNode\r\nexport function constant(value: string | undefined, info?: Info): StrNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\r\n  return { operation: \"const\", operands: [], value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): NumNode {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { key: \"_\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\r\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\r\n  return { operation: \"lookup\", operands, table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Num[]): NumNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Num[]): NumNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Num[]): NumNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Num[]): NumNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Num, c: Num): NumNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Num): NumNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\r\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\r\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\n/**\r\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\r\n */\r\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: Any[]): AnyNode[]\r\nfunction intoOps(values: Any[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: Num | Str): NumNode | StrNode\r\nfunction intoV(value: Any): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\n\r\ntype _NodeList = {\r\n  [key: string]: NodeList\r\n} & {\r\n  operation?: never\r\n}\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n\r\n/**\r\n * `v1` === `v2` ? `match` : `unmatch`\r\n * @deprecated Use `equal`, `unequal`, or `equalStr` instead\r\n */\r\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\r\n}\r\n","import { AnyNode, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\r\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\r\n\r\n  function traverse(formula: (NumNode | StrNode)) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\r\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\r\n  const visiting = new Set<(NumNode | StrNode)>()\r\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n\r\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\r\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\r\n  const visiting = new Set<AnyNode>()\r\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n\r\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\r\n    let topDownMapping = topDownByContext.get(parentContextId)\r\n    if (!topDownMapping) {\r\n      topDownMapping = new Map()\r\n      topDownByContext.set(parentContextId, topDownMapping)\r\n    }\r\n\r\n    let topDown = topDownMapping.get(formula)\r\n    if (topDown) return topDown\r\n    let topDownContextId: number\r\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n\r\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\r\n    if (!bottomUpMapping) {\r\n      bottomUpMapping = new Map()\r\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\r\n    }\r\n\r\n    let bottomUp = bottomUpMapping.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    visiting.add(topDown)\r\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\r\n    visiting.delete(topDown)\r\n\r\n    bottomUpMapping.set(topDown, bottomUp)\r\n    topDownMapping.set(formula, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\r\n    const operands = formula.operands.map(f => check(f, contextId))\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(f => check(f, baseContextId))\r\n  return arrayEqual(formulas, result) ? formulas : result\r\n}\r\n\r\ntype ContextID = number\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import { assertUnreachable, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { constant } from \"./utils\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], binding: (readNode: ReadNode<number>) => string): (values: Dict<string, number>) => number[] {\r\n  // TODO: Use min-cut to minimize the size of interim array\r\n  type Reference = string | number | { ins: Reference[] }\r\n\r\n  const uniqueReadStrings = new Set<string>()\r\n  const uniqueNumbers = new Set<number>()\r\n  const mapping = new Map<NumNode, Reference>()\r\n\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation } = f\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || (f.accu && f.accu !== \"add\"))\r\n          throw new Error(`Unsupported ${operation} node in precompute`)\r\n        const name = binding(f)\r\n        uniqueReadStrings.add(name)\r\n        mapping.set(f, name)\r\n        break\r\n      case \"add\": case \"min\": case \"max\": case \"mul\":\r\n      case \"threshold\": case \"res\": case \"sum_frac\":\r\n        mapping.set(f, { ins: f.operands.map(op => mapping.get(op)!) })\r\n        break\r\n      case \"const\":\r\n        if (typeof f.value !== \"number\")\r\n          throw new Error(\"Found string constant while precomputing\")\r\n        const value = f.value\r\n        uniqueNumbers.add(value)\r\n        mapping.set(f as ConstantNode<number>, value)\r\n        break\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\": case \"small\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  /**\r\n   * [ Outputs , Input , Constants, Deduplicated Compute ]\r\n   *\r\n   * Note that only Compute nodes are deduplicated. Outputs are arranged\r\n   * in the same order as formulas even when they are duplicated. Inputs\r\n   * are arranged in the same order as the read strings, even when they\r\n   * overlap with outputs. If an output is a constant or a compute node,\r\n   * only put the data in the output region.\r\n   */\r\n  const locations = new Map<NumNode | number | string, number>()\r\n\r\n  const readStrings = [...uniqueReadStrings], readOffset = formulas.length\r\n  const constValues = [...uniqueNumbers]\r\n  const computations: { out: number, ins: number[], op: (_: number[]) => number, buff: number[] }[] = []\r\n\r\n  formulas.forEach((f, i) => {\r\n    locations.set(f, i)\r\n    if (f.operation === \"const\") locations.set(f.value, i)\r\n  })\r\n  // After this line, if some outputs are also read node, `locations`\r\n  // will point to the one in the read node portion instead.\r\n  readStrings.forEach((str, i) => locations.set(str, i + formulas.length))\r\n  let offset = formulas.length + readStrings.length\r\n  constValues.forEach(value => locations.has(value) || locations.set(value, offset++))\r\n\r\n  // `locations` is stable from this point on. We now only append new values.\r\n  // There is no change to existing values.\r\n  //\r\n  // DO NOT read from `location` prior to this line.\r\n  mapping.forEach((ref, node) => {\r\n    if (typeof ref !== \"object\") {\r\n      locations.set(node, locations.get(ref)!)\r\n      return\r\n    }\r\n    if (!locations.has(node)) locations.set(node, offset++)\r\n    computations.push({\r\n      out: locations.get(node)!,\r\n      ins: node.operands.map(op => locations.get(op)!),\r\n      op: allOperations[node.operation],\r\n      buff: Array(node.operands.length).fill(0),\r\n    })\r\n  })\r\n\r\n  const buffer = Array(offset).fill(0)\r\n  buffer.forEach((_, i, array) => array[i] = NaN)\r\n  uniqueNumbers.forEach(number => buffer[locations.get(number)!] = number)\r\n\r\n  // Copy target for when some outputs are duplicated\r\n  const copyList = formulas.map((node, i) => {\r\n    const src = locations.get(node)!\r\n    return src !== i ? [src, i] : undefined!\r\n  }).filter(x => x)\r\n  const copyFormula = copyList.length ? () => {\r\n    copyList.forEach(([src, dst]) => buffer[dst] = buffer[src])\r\n  } : undefined\r\n\r\n  return values => {\r\n    readStrings.forEach((id, i) => buffer[readOffset + i] = values[id] ?? 0)\r\n    computations.forEach(({ out, ins, op, buff }) => {\r\n      ins.forEach((i, j) => buff[j] = buffer[i])\r\n      buffer[out] = op(buff)\r\n    })\r\n    copyFormula?.()\r\n    return buffer\r\n  }\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? fold(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = fold(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\r\n        if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = fold(operands[operands.length - 1], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","import { optimize, precompute } from '../../../../Formula/optimization';\r\nimport type { NumNode } from '../../../../Formula/type';\r\nimport type { MainStatKey, SubstatKey } from '../../../../Types/artifact';\r\nimport { ArtifactSetKey, SlotKey } from '../../../../Types/consts';\r\nimport { countBuilds, filterArts, mergePlot, pruneAll } from './common';\r\n\r\nlet id: string\r\nlet builds: Build[]\r\nlet buildValues: number[] | undefined\r\nlet plotData: PlotData | undefined\r\nlet threshold: number\r\n\r\ntype WorkerStat = {\r\n  arts: ArtifactsBySlot\r\n  nodes: NumNode[]\r\n\r\n  maxBuilds: number\r\n  min: number[]\r\n\r\n  callback: (interim: InterimResult) => void\r\n}\r\nlet shared: WorkerStat = undefined as any\r\n\r\nexport function setup(msg: Setup, callback: WorkerStat[\"callback\"]): RequestResult {\r\n  shared = { ...msg } as any\r\n  shared.nodes = msg.filters.map(x => x.value)\r\n  shared.min = msg.filters.map(x => x.min)\r\n  shared.callback = callback\r\n  shared.nodes.push(msg.optimizationTarget)\r\n  if (msg.plotBase) {\r\n    plotData = {}\r\n    shared.nodes.push(msg.plotBase)\r\n  }\r\n  id = msg.id\r\n  builds = []\r\n  buildValues = undefined\r\n  threshold = -Infinity\r\n\r\n  return { command: \"request\", id }\r\n}\r\n\r\nexport function request({ threshold: newThreshold, filter: filters }: Request): RequestResult & { total: number } {\r\n  if (threshold > newThreshold) threshold = newThreshold\r\n  let preArts = filterArts(shared.arts, filters)\r\n  const totalCount = countBuilds(preArts)\r\n\r\n  let nodes = optimize(shared.nodes, {}, _ => false);\r\n  ({ nodes, arts: preArts } = pruneAll(nodes, shared.min, preArts, shared.maxBuilds, new Set(), {\r\n    pruneArtRange: true, pruneNodeRange: true,\r\n  }))\r\n  const compute = precompute(nodes, f => f.path[1])\r\n  const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\r\n\r\n  const ids: string[] = Array(arts.length).fill(\"\")\r\n  let count = { build: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\r\n\r\n  function permute(i: number, stats: Stats) {\r\n    if (i < 0) {\r\n      const result = compute(stats)\r\n      if (shared.min.every((m, i) => (m <= result[i]))) {\r\n        const value = result[shared.min.length]\r\n        let build: Build | undefined\r\n        if (value >= threshold) {\r\n          build = { value, artifactIds: [...ids] }\r\n          builds.push(build)\r\n        }\r\n        if (plotData) {\r\n          const x = result[shared.min.length + 1]\r\n          if (!plotData[x] || plotData[x]!.value < value) {\r\n            if (!build) build = { value, artifactIds: [...ids] }\r\n            build.plot = x\r\n            plotData[x] = build\r\n          }\r\n        }\r\n      }\r\n      else count.failed += 1\r\n      return\r\n    }\r\n    arts[i].forEach(art => {\r\n      ids[i] = art.id\r\n\r\n      const newStats = { ...stats }\r\n      Object.entries(art.values).forEach(([key, value]) =>\r\n        newStats[key] = (newStats[key] ?? 0) + value)\r\n\r\n      permute(i - 1, newStats)\r\n    })\r\n    if (i === 0) {\r\n      count.build += arts[0].length\r\n      if (count.build > 8192)\r\n        interimReport(count)\r\n    }\r\n  }\r\n\r\n  permute(arts.length - 1, preArts.base)\r\n  interimReport(count)\r\n  return { command: \"request\", id, total: totalCount }\r\n}\r\nexport function finalize(): FinalizeResult {\r\n  refresh(true)\r\n  return { command: \"finalize\", id, builds, plotData }\r\n}\r\n\r\nexport let interimReport = (count: { build: number, failed: number, skipped: number }): void => {\r\n  refresh(false)\r\n  shared.callback({\r\n    command: \"interim\", id, buildValues,\r\n    buildCount: count.build, failedCount: count.failed, skippedCount: count.skipped\r\n  })\r\n  buildValues = undefined\r\n  count.build = 0\r\n  count.failed = 0\r\n  count.skipped = 0\r\n}\r\nfunction refresh(force: boolean): void {\r\n  if (plotData && Object.keys(plotData).length >= 100000)\r\n    plotData = mergePlot([plotData])\r\n\r\n  if (builds.length >= 100000 || force) {\r\n    builds = builds\r\n      .sort((a, b) => b.value - a.value)\r\n      .slice(0, shared.maxBuilds)\r\n    buildValues = builds.map(x => x.value)\r\n    threshold = Math.max(threshold, buildValues[shared.maxBuilds - 1] ?? -Infinity)\r\n  }\r\n}\r\n\r\ntype Stats = { [key in MainStatKey | SubstatKey]?: number }\r\nexport type ArtifactBuildData = {\r\n  id: string\r\n  set: ArtifactSetKey\r\n  values: DynStat\r\n}\r\n\r\nexport type Command = Setup | Request | Finalize\r\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\r\nexport type DynStat = { [key in string]: number }\r\nexport interface Setup {\r\n  command: \"setup\"\r\n\r\n  id: string\r\n  arts: ArtifactsBySlot\r\n\r\n  optimizationTarget: NumNode\r\n  filters: { value: NumNode, min: number }[]\r\n  plotBase: NumNode | undefined,\r\n  maxBuilds: number\r\n}\r\nexport interface Request {\r\n  command: \"request\"\r\n  threshold: number\r\n  filter: RequestFilter\r\n}\r\nexport type RequestFilter = StrictDict<SlotKey,\r\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"id\", ids: Set<string> }\r\n>\r\nexport type PlotData = Dict<number, Build>\r\n\r\nexport type ChartData = {\r\n  valueNode: NumNode,\r\n  plotNode: NumNode,\r\n  data: Build[]\r\n}\r\nexport interface Finalize {\r\n  command: \"finalize\"\r\n}\r\n\r\nexport type WorkerResult = InterimResult | RequestResult | FinalizeResult | DebugMsg\r\nexport interface InterimResult {\r\n  command: \"interim\"\r\n  id: string\r\n  buildValues: number[] | undefined\r\n  /** The number of builds since last report, including failed builds */\r\n  buildCount: number\r\n  /** The number of builds that does not meet the min-filter requirement since last report */\r\n  failedCount: number\r\n  skippedCount: number\r\n}\r\nexport interface FinalizeResult {\r\n  command: \"finalize\"\r\n  id: string\r\n  builds: Build[]\r\n  plotData?: PlotData\r\n}\r\nexport interface RequestResult {\r\n  command: \"request\"\r\n  id: string\r\n}\r\nexport interface Build {\r\n  value: number\r\n  plot?: number\r\n  artifactIds: string[]\r\n}\r\nexport interface DebugMsg {\r\n  command: \"debug\"\r\n  id: string\r\n  value: any\r\n}\r\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\r\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\r\nexport const allReactionModes = [\"hydro_vaporize\", \"pyro_vaporize\", \"pyro_melt\", \"cryo_melt\",] as const\r\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\r\nexport const allRarities = [5, 4, 3, 2, 1] as const\r\nexport const allArtifactRarities = [5, 4, 3] as const\r\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\r\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo'] as const\r\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\r\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\r\nexport const allArtifactSets = [\r\n  \"Adventurer\",\r\n  \"ArchaicPetra\",\r\n  \"Berserker\",\r\n  \"BlizzardStrayer\",\r\n  \"BloodstainedChivalry\",\r\n  \"BraveHeart\",\r\n  \"CrimsonWitchOfFlames\",\r\n  \"DefendersWill\",\r\n  \"EchoesOfAnOffering\",\r\n  \"EmblemOfSeveredFate\",\r\n  \"Gambler\",\r\n  \"GladiatorsFinale\",\r\n  \"HeartOfDepth\",\r\n  \"HuskOfOpulentDreams\",\r\n  \"Instructor\",\r\n  \"Lavawalker\",\r\n  \"LuckyDog\",\r\n  \"MaidenBeloved\",\r\n  \"MartialArtist\",\r\n  \"NoblesseOblige\",\r\n  \"OceanHuedClam\",\r\n  \"PaleFlame\",\r\n  \"PrayersForDestiny\",\r\n  \"PrayersForIllumination\",\r\n  \"PrayersForWisdom\",\r\n  \"PrayersToSpringtime\",\r\n  \"ResolutionOfSojourner\",\r\n  \"RetracingBolide\",\r\n  \"Scholar\",\r\n  \"ShimenawasReminiscence\",\r\n  \"TenacityOfTheMillelith\",\r\n  \"TheExile\",\r\n  \"ThunderingFury\",\r\n  \"Thundersoother\",\r\n  \"TinyMiracle\",\r\n  \"TravelingDoctor\",\r\n  \"VermillionHereafter\",\r\n  \"ViridescentVenerer\",\r\n  \"WanderersTroupe\",\r\n] as const\r\nexport const allCharacterKeys = [\r\n  \"Albedo\",\r\n  \"Amber\",\r\n  \"Barbara\",\r\n  \"Beidou\",\r\n  \"Bennett\",\r\n  \"Chongyun\",\r\n  \"Diluc\",\r\n  \"Diona\",\r\n  \"Fischl\",\r\n  \"Ganyu\",\r\n  \"HuTao\",\r\n  \"Jean\",\r\n  \"Kaeya\",\r\n  \"Keqing\",\r\n  \"Klee\",\r\n  \"KujouSara\",\r\n  \"Lisa\",\r\n  \"Mona\",\r\n  \"Ningguang\",\r\n  \"Noelle\",\r\n  \"Qiqi\",\r\n  \"Razor\",\r\n  \"Sucrose\",\r\n  \"Tartaglia\",\r\n  \"Traveler\",\r\n  \"RaidenShogun\",\r\n  \"Venti\",\r\n  \"Xiangling\",\r\n  \"Xiao\",\r\n  \"Xingqiu\",\r\n  \"Xinyan\",\r\n  \"Rosaria\",\r\n  \"Yanfei\",\r\n  \"Eula\",\r\n  \"KaedeharaKazuha\",\r\n  \"KamisatoAyaka\",\r\n  \"Sayu\",\r\n  \"Shenhe\",\r\n  \"Yoimiya\",\r\n  \"Aloy\",\r\n  \"SangonomiyaKokomi\",\r\n  \"Thoma\",\r\n  \"Gorou\",\r\n  \"AratakiItto\",\r\n  \"YaeMiko\",\r\n  \"YunJin\",\r\n  \"Zhongli\",\r\n  \"KamisatoAyato\"\r\n] as const\r\n\r\nexport const allWeaponSwordKeys = [\r\n  \"AmenomaKageuchi\",\r\n  \"AquilaFavonia\",\r\n  \"BlackcliffLongsword\",\r\n  \"CinnabarSpindle\",\r\n  \"CoolSteel\",\r\n  \"DarkIronSword\",\r\n  \"DullBlade\",\r\n  \"FavoniusSword\",\r\n  \"FesteringDesire\",\r\n  \"FilletBlade\",\r\n  \"FreedomSworn\",\r\n  \"HaranGeppakuFutsu\",\r\n  \"HarbingerOfDawn\",\r\n  \"IronSting\",\r\n  \"LionsRoar\",\r\n  \"MistsplitterReforged\",\r\n  \"PrimordialJadeCutter\",\r\n  \"PrototypeRancour\",\r\n  \"RoyalLongsword\",\r\n  \"SacrificialSword\",\r\n  \"SilverSword\",\r\n  \"SkyriderSword\",\r\n  \"SkywardBlade\",\r\n  \"SummitShaper\",\r\n  \"SwordOfDescension\",\r\n  \"TheAlleyFlash\",\r\n  \"TheBlackSword\",\r\n  \"TheFlute\",\r\n  \"TravelersHandySword\",\r\n] as const\r\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\r\n\r\nexport const allWeaponClaymoreKeys = [\r\n  \"Akuoumaru\",\r\n  \"BlackcliffSlasher\",\r\n  \"BloodtaintedGreatsword\",\r\n  \"DebateClub\",\r\n  \"FavoniusGreatsword\",\r\n  \"FerrousShadow\",\r\n  \"KatsuragikiriNagamasa\",\r\n  \"LithicBlade\",\r\n  \"LuxuriousSeaLord\",\r\n  \"OldMercsPal\",\r\n  \"PrototypeArchaic\",\r\n  \"Rainslasher\",\r\n  \"RedhornStonethresher\",\r\n  \"RoyalGreatsword\",\r\n  \"SacrificialGreatsword\",\r\n  \"SerpentSpine\",\r\n  \"SkyriderGreatsword\",\r\n  \"SkywardPride\",\r\n  \"SnowTombedStarsilver\",\r\n  \"SongOfBrokenPines\",\r\n  \"TheBell\",\r\n  \"TheUnforged\",\r\n  \"WasterGreatsword\",\r\n  \"Whiteblind\",\r\n  \"WhiteIronGreatsword\",\r\n  \"WolfsGravestone\",\r\n] as const\r\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\r\n\r\nexport const allWeaponPolearmKeys = [\r\n  \"BeginnersProtector\",\r\n  \"BlackcliffPole\",\r\n  \"BlackTassel\",\r\n  \"CalamityQueller\",\r\n  \"CrescentPike\",\r\n  \"Deathmatch\",\r\n  \"DragonsBane\",\r\n  \"DragonspineSpear\",\r\n  \"EngulfingLightning\",\r\n  \"FavoniusLance\",\r\n  \"Halberd\",\r\n  \"IronPoint\",\r\n  \"KitainCrossSpear\",\r\n  \"LithicSpear\",\r\n  \"PrimordialJadeWingedSpear\",\r\n  \"PrototypeStarglitter\",\r\n  \"RoyalSpear\",\r\n  \"SkywardSpine\",\r\n  \"StaffOfHoma\",\r\n  \"TheCatch\",\r\n  \"VortexVanquisher\",\r\n  \"WavebreakersFin\",\r\n  \"WhiteTassel\",\r\n] as const\r\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\r\n\r\nexport const allWeaponBowKeys = [\r\n  \"AlleyHunter\",\r\n  \"AmosBow\",\r\n  \"BlackcliffWarbow\",\r\n  \"CompoundBow\",\r\n  \"ElegyForTheEnd\",\r\n  \"FavoniusWarbow\",\r\n  \"Hamayumi\",\r\n  \"HuntersBow\",\r\n  \"Messenger\",\r\n  \"MitternachtsWaltz\",\r\n  \"MouunsMoon\",\r\n  \"PolarStar\",\r\n  \"Predator\",\r\n  \"PrototypeCrescent\",\r\n  \"RavenBow\",\r\n  \"RecurveBow\",\r\n  \"RoyalBow\",\r\n  \"Rust\",\r\n  \"SacrificialBow\",\r\n  \"SeasonedHuntersBow\",\r\n  \"SharpshootersOath\",\r\n  \"SkywardHarp\",\r\n  \"Slingshot\",\r\n  \"TheStringless\",\r\n  \"TheViridescentHunt\",\r\n  \"ThunderingPulse\",\r\n  \"WindblumeOde\",\r\n] as const\r\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\r\n\r\nexport const allWeaponCatalystKeys = [\r\n  \"ApprenticesNotes\",\r\n  \"BlackcliffAgate\",\r\n  \"DodocoTales\",\r\n  \"EmeraldOrb\",\r\n  \"EverlastingMoonglow\",\r\n  \"EyeOfPerception\",\r\n  \"FavoniusCodex\",\r\n  \"Frostbearer\",\r\n  \"HakushinRing\",\r\n  \"KagurasVerity\",\r\n  \"LostPrayerToTheSacredWinds\",\r\n  \"MagicGuide\",\r\n  \"MappaMare\",\r\n  \"MemoryOfDust\",\r\n  \"OathswornEye\",\r\n  \"OtherworldlyStory\",\r\n  \"PocketGrimoire\",\r\n  \"PrototypeAmber\",\r\n  \"RoyalGrimoire\",\r\n  \"SacrificialFragments\",\r\n  \"SkywardAtlas\",\r\n  \"SolarPearl\",\r\n  \"TheWidsith\",\r\n  \"ThrillingTalesOfDragonSlayers\",\r\n  \"TwinNephrite\",\r\n  \"WineAndSong\",\r\n] as const\r\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\r\n\r\nexport const allWeaponKeys = [\r\n  ...allWeaponSwordKeys,\r\n  ...allWeaponClaymoreKeys,\r\n  ...allWeaponPolearmKeys,\r\n  ...allWeaponBowKeys,\r\n  ...allWeaponCatalystKeys,\r\n] as const\r\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\r\n\r\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\"] as const\r\n\r\nexport type HitModeKey = typeof allHitModes[number]\r\nexport type Region = typeof allRegions[number]\r\nexport type ReactionModeKey = typeof allReactionModes[number]\r\nexport type SetNum = typeof allArtifactSetCount[number]\r\nexport type Rarity = typeof allRarities[number]\r\nexport type ArtifactRarity = typeof allArtifactRarities[number]\r\nexport type SlotKey = typeof allSlotKeys[number]\r\nexport type ElementKey = typeof allElements[number]\r\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\r\nexport type ArtifactSetKey = typeof allArtifactSets[number]\r\nexport type CharacterKey = typeof allCharacterKeys[number]\r\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\r\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\r\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\r\n","import { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\r\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\r\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\r\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\r\nimport { allSlotKeys, ArtifactSetKey } from \"../../../../Types/consts\";\r\nimport { assertUnreachable, objectKeyMap, objectMap } from \"../../../../Util/Util\";\r\nimport type { ArtifactBuildData, ArtifactsBySlot, Build, DynStat, PlotData, RequestFilter } from \"./background\";\r\n\r\ntype DynMinMax = { [key in string]: MinMax }\r\ntype MinMax = { min: number, max: number }\r\n\r\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\r\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, keepArtifacts: Set<ArtifactSetKey>, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  let should = forced\r\n  /** If `key` makes progress, all operations in `value` should be performed */\r\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\r\n    pruneOrder: { pruneNodeRange: true },\r\n    pruneArtRange: { pruneNodeRange: true },\r\n    pruneNodeRange: { reaffine: true },\r\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\r\n  }\r\n  let count = 0\r\n  while (Object.values(should).some(x => x) && count++ < 20) {\r\n    if (should.pruneOrder) {\r\n      delete should.pruneOrder\r\n      const newArts = pruneOrder(arts, numTop, keepArtifacts)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneOrder }\r\n      }\r\n    }\r\n    if (should.pruneArtRange) {\r\n      delete should.pruneArtRange\r\n      const newArts = pruneArtRange(nodes, arts, minimum)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneArtRange }\r\n      }\r\n    }\r\n    if (should.pruneNodeRange) {\r\n      delete should.pruneNodeRange\r\n      const newNodes = pruneNodeRange(nodes, arts)\r\n      if (nodes !== newNodes) {\r\n        nodes = newNodes\r\n        should = { ...should, ...deps.pruneNodeRange }\r\n      }\r\n    }\r\n    if (should.reaffine) {\r\n      delete should.reaffine\r\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\r\n      if (nodes !== newNodes || arts !== newArts) {\r\n        nodes = newNodes\r\n        arts = newArts\r\n        should = { ...should, ...deps.reaffine }\r\n      }\r\n    }\r\n  }\r\n  return { nodes, arts }\r\n}\r\n\r\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\r\n\r\n  function visit(node: NumNode, isAffine: boolean) {\r\n    if (isAffine) affineNodes.add(node)\r\n    else node.operands.forEach(_op => {\r\n      const op = _op as NumNode\r\n      affineNodes.has(op) && topLevelAffine.add(op)\r\n    })\r\n  }\r\n\r\n  const dynKeys = new Set<string>()\r\n\r\n  forEachNodes(nodes, _ => { }, f => {\r\n    const operation = f.operation\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\r\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\r\n        dynKeys.add(f.path[1])\r\n        visit(f, true)\r\n        break\r\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\r\n      case \"mul\": {\r\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\r\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\r\n        break\r\n      }\r\n      case \"const\":\r\n        if (typeof f.value === \"string\" || f.value === undefined)\r\n          throw new Error(`Found constant ${f.value} while compacting`)\r\n        visit(f as NumNode, true); break\r\n      case \"res\": case \"threshold\": case \"sum_frac\":\r\n      case \"max\": case \"min\": visit(f, false); break\r\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\r\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\r\n    Object.keys(arts.base).length === dynKeys.size)\r\n    return { nodes, arts }\r\n\r\n  let current = -1\r\n  function nextDynKey(): string {\r\n    while (dynKeys.has(`${++current}`));\r\n    return `${current}`\r\n  }\r\n\r\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\r\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\r\n  const affineMap = new Map(affine.map(node => [node,\r\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\r\n      ? node\r\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\r\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\r\n\r\n  function reaffineArt(stat: DynStat): DynStat {\r\n    const values = constantFold([...affineMap.keys()], {\r\n      dyn: objectMap(stat, (value) => constant(value))\r\n    } as any, _ => true)\r\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\r\n  }\r\n  const result = {\r\n    nodes, arts: {\r\n      base: reaffineArt(arts.base),\r\n      values: objectKeyMap(allSlotKeys, slot =>\r\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\r\n    }\r\n  }\r\n  const offsets = Object.entries(reaffineArt({}))\r\n  for (const arts of Object.values(result.arts.values))\r\n    for (const { values } of arts)\r\n      for (const [key, baseValue] of offsets)\r\n        values[key] -= baseValue\r\n  return result\r\n}\r\n/** Remove artifacts that cannot be in top `numTop` builds */\r\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, keepArtifacts: Set<ArtifactSetKey>): ArtifactsBySlot {\r\n  let progress = false\r\n  const values = objectKeyMap(allSlotKeys, slot => {\r\n    const list = arts.values[slot]\r\n    const newList = list.filter(art => {\r\n      let count = 0\r\n      return list.every(other => {\r\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\r\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\r\n        if (greaterEqual && (greater || other.id > art.id) &&\r\n          (!keepArtifacts.has(art.set) || art.set === other.set))\r\n          count++\r\n        return count < numTop\r\n      })\r\n    })\r\n    if (newList.length !== list.length) progress = true\r\n    return newList\r\n  })\r\n  return progress ? { base: arts.base, values } : arts\r\n}\r\n/** Remove artifacts that cannot reach `minimum` in any build */\r\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const wrap = { arts }\r\n  while (true) {\r\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\r\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\r\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\r\n\r\n    let progress = false\r\n    const values = objectKeyMap(allSlotKeys, slot => {\r\n      const result = wrap.arts.values[slot].filter(art => {\r\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\r\n        const newRange = computeNodeRange(nodes, read)\r\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\r\n      })\r\n      if (result.length !== wrap.arts.values[slot].length)\r\n        progress = true\r\n      return result\r\n    })\r\n    if (!progress) break\r\n    wrap.arts = { base: wrap.arts.base, values }\r\n  }\r\n  return wrap.arts\r\n}\r\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n  const nodeRange = computeNodeRange(nodes, reads)\r\n\r\n  return mapFormulas(nodes, f => {\r\n    const { operation } = f\r\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\r\n    switch (operation) {\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandRanges\r\n        if (value.min >= threshold.max) return f.operands[2]\r\n        else if (value.max < threshold.min) return constant(0)\r\n        if (pass.max === pass.min &&\r\n          fail.max === fail.min &&\r\n          pass.min === fail.min && isFinite(pass.min))\r\n          return constant(pass.max)\r\n        break\r\n      }\r\n      case \"min\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\r\n        break\r\n      }\r\n      case \"max\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every(op2 => op1.max >= op2.min)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\r\n        break\r\n      }\r\n    }\r\n    return f\r\n  }, f => f)\r\n}\r\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  ranges.forEach(range => {\r\n    Object.entries(range).forEach(([key, value]) => {\r\n      if (result[key]) {\r\n        result[key].min += value.min\r\n        result[key].max += value.max\r\n      } else result[key] = { ...value }\r\n    })\r\n  })\r\n  return result\r\n}\r\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  if (arts.length) {\r\n    Object.keys(arts[0].values)\r\n      .filter(key => arts.every(art => art.values[key]))\r\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\r\n    arts.forEach(({ values }) => {\r\n      for (const [key, value] of Object.entries(values)) {\r\n        if (!result[key]) result[key] = { min: 0, max: value }\r\n        else {\r\n          if (result[key].max < value) result[key].max = value\r\n          if (result[key].min > value) result[key].min = value\r\n        }\r\n      }\r\n    })\r\n  }\r\n  return result\r\n}\r\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\r\n  const range = new Map<NumNode, MinMax>()\r\n\r\n  forEachNodes(nodes, _ => { }, _f => {\r\n    const f = _f as NumNode\r\n    const { operation } = f\r\n    const operands = f.operands.map(op => range.get(op)!)\r\n    let current: MinMax\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.path[0] !== \"dyn\")\r\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\r\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\r\n        break\r\n      case \"const\": current = computeMinMax([f.value]); break\r\n      case \"subscript\": current = computeMinMax(f.list); break\r\n      case \"add\": case \"min\": case \"max\":\r\n        current = {\r\n          min: allOperations[operation](operands.map(x => x.min)),\r\n          max: allOperations[operation](operands.map(x => x.max)),\r\n        }; break\r\n      case \"res\": current = {\r\n        min: allOperations[operation]([operands[0].max]),\r\n        max: allOperations[operation]([operands[0].min]),\r\n      }; break\r\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\r\n        accu.min * current.min, accu.min * current.max,\r\n        accu.max * current.min, accu.max * current.max,\r\n      ])); break\r\n      case \"threshold\":\r\n        if (operands[0].min >= operands[1].max) current = operands[2]\r\n        else if (operands[0].max < operands[1].min) current = computeMinMax([0])\r\n        else current = computeMinMax([0], [operands[2]])\r\n        break\r\n      case \"sum_frac\": {\r\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\r\n        if (sum.min <= 0 && sum.max >= 0)\r\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\r\n        else\r\n          // TODO: Check this\r\n          current = computeMinMax([\r\n            x.min / sum.min, x.min / sum.max,\r\n            x.max / sum.min, x.max / sum.max\r\n          ])\r\n        break\r\n      }\r\n      case \"data\": case \"lookup\": case \"match\":\r\n        throw new Error(`Unsupported ${operation} node`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n    range.set(f, current)\r\n  })\r\n  return range\r\n}\r\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\r\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\r\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\r\n  return { min, max }\r\n}\r\n\r\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\r\n  return {\r\n    base: arts.base,\r\n    values: objectKeyMap(allSlotKeys, slot => {\r\n      const filter = filters[slot]\r\n      switch (filter.kind) {\r\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\r\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set))\r\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\r\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\r\n}\r\nexport function mergePlot(plots: PlotData[]): PlotData {\r\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\r\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\r\n  while (keys.size > maxCount) {\r\n    scale *= reductionScaling\r\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\r\n  }\r\n  const result: PlotData = {}\r\n  for (const plot of plots)\r\n    for (const build of Object.values(plot)) {\r\n      const x = Math.round(build.plot! / scale) * scale\r\n      if (!result[x] || result[x]!.value < build.value)\r\n        result[x] = build\r\n    }\r\n  return result\r\n}\r\n\r\nexport function countBuilds(arts: ArtifactsBySlot): number {\r\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\r\n}\r\n","import { Command, setup, request, finalize } from \"./background\"\r\nimport { assertUnreachable } from '../../../../Util/Util';\r\n\r\nonmessage = ({ data }: { data: Command }) => {\r\n  const command = data.command\r\n  switch (command) {\r\n    case \"setup\": postMessage(setup(data, interim => postMessage(interim, undefined))); break\r\n    case \"request\": postMessage(request(data)); break\r\n    case \"finalize\": postMessage(finalize()); break\r\n    default: assertUnreachable(command)\r\n  }\r\n}\r\n"],"names":["runtime","exports","undefined","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","key","value","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","GenStateSuspendedStart","method","arg","GenStateExecuting","Error","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","GenStateSuspendedYield","makeInvokeMethod","fn","call","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","this","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","PromiseImpl","invoke","resolve","reject","result","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","o","minLen","n","toString","from","test","isArray","_i","_s","_e","_arr","_n","_d","_defineProperty","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","apply","_objectSpread2","target","arguments","source","getOwnPropertyDescriptors","defineProperties","_createForOfIteratorHelper","allowArrayLike","it","F","s","e","f","normalCompletion","didErr","step","_e2","objPathValue","console","reduce","a","k","objectKeyMap","map","fromEntries","objectMap","entries","v","assertUnreachable","constant","NaN","percent","operation","operands","Number","MAX_VALUE","Infinity","min","intoOps","max","customRead","path","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","b","every","allCommutativeMonoidOperations","x","Math","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","common","counts","factored","count","fill","candidatesByOperation","remainingCounts","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","v1","v2","match","unmatch","list","accu","nextContext","id","builds","buildValues","plotData","allSlotKeys","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","_","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","offsets","baseValue","pruneOrder","numTop","keepArtifacts","progress","newList","art","other","greaterEqual","greater","some","pruneArtRange","minimum","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","pruneNodeRange","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","range","reads","_f","computeMinMax","c","sum","minMaxes","countBuilds","_count","shared","request","newThreshold","filters","preArts","kind","ids","sets","filterArts","totalCount","optimize","forced","should","deps","newArts","newNodes","pruneAll","maxBuilds","compute","binding","uniqueReadStrings","uniqueNumbers","mapping","ins","locations","readStrings","readOffset","constValues","computations","str","offset","ref","out","buff","buffer","number","copyList","src","copyFormula","dst","precompute","sort","build","failed","skipped","permute","stats","m","artifactIds","plot","newStats","interimReport","command","refresh","callback","buildCount","failedCount","skippedCount","force","plots","scale","round","mergePlot","onmessage","msg","postMessage","interim","optimizationTarget","plotBase"],"sourceRoot":""}